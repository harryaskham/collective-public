* NixOS configs

Public subset of personal NixOS config.

Heavily experimental; strongly suggest not depending directly on the flake.
My actual usage of these libraries is in a separate private repo with my machine configurations.
Exposes the ~pkgs/collective-lib~ library containing config-wide utilities and libraries, including:

** ~typelib.nix~
Bootstraps a type system separate from that used by Nix's modules.
- Bootstrap system constructed manually at level ~0~ such that ~typeOf Type_0 == Type_0~.
- Each subsequent level ~l~ is then constructed in terms of levels ~l~ (where no circularity is required) or ~l - 1~ (where using ~l~ would introduce circularity).
- At ~l == 4~, no ~U_0~ shim types remain, and creating a new ~Type~ type using level ~4~ constructs just produces an exact match for ~Type_4~ (e.g. ~Type_4 "Type" { ... } == Type_4~).
- Since ~Type_4 == Type_5 == ...~, exposes the type system at level ~4~ as ~collective-lib.typed~, which overrides e.g. ~lib.typeOf~ and related machinery to handle these types alongside language builtins and the module system.

Enables a fun syntax for defining typed functions:

#+BEGIN_SRC nix
with defun (
  {f}: {a ? Int, b ? Literal 7}: 
  where f [a b] (a.value + b.getLiteral{})
);
{
  _0 = f 1 7;
  _1 = f 2.2 7;
  _2 = f 1 8;
}
#+END_SRC

#+BEGIN_SRC nix
{
  _0 = 8; 
  _1 = <type error on Float/Int>
  _2 = <type error on Literal>
}
#+END_SRC

** ~script-utils/~
Richer code-gen than standard Nix builders provide for building up CLI command trees.
Lets you keep personal scripts / utilities clean and organised.

** ~eval/~
- Evaluate Nix expressions from strings (~eval "1 + 1" == 2~).
- Implemented two ways:
  - First way uses import-from-derivation and caches the lambda in the Nix store.
  - Second way uses ~parser/~ to do everything in the evaluator without derivations.
- Implements serialisable lambdas, e.g. ~(let f = typefn "a: b: a + b"; in f 1 2) == 3~.

#+BEGIN_SRC nix
eval ''let xs = { a = 1; b = 2; }; f = {a, c ? 3, ...}: a + c; in { r = f xs; }.r or null''
#+END_SRC

gives:

#+BEGIN_SRC
Right 4
#+END

which is computed by reducing the parsed AST below.

** ~parser/~
A ~nix-parsec~-based Nix parser written in Nix, which can reflect on module source, perform code transformations, etc.

#+BEGIN_SRC nix
toString (parse ''let xs = { a = 1; b = 2; }; f = {a, c ? 3, ...}: a + c; in { r = f xs; }.r or null'')
#+END_SRC

gives:

#+BEGIN_SRC
let _ in _
├─bindings
│ ├─0
│ │ └─<_ = _>
│ │   ├─lhs
│ │   │ └─`xs`
│ │   │
│ │   └─rhs
│ │     └─{_}
│ │       ├─isRec
│ │       │  └─false
│ │       └─assignments
│ │         ├─0
│ │         │ └─<_ = _>
│ │         │   ├─lhs
│ │         │   │ └─`a`
│ │         │   │
│ │         │   └─rhs
│ │         │     └─ℤ 1
│ │         │
│ │         └─1
│ │           └─<_ = _>
│ │             ├─lhs
│ │             │ └─`b`
│ │             │
│ │             └─rhs
│ │               └─ℤ 2
│ │
│ └─1
│   └─<_ = _>
│     ├─lhs
│     │ └─`f`
│     │
│     └─rhs
│       └─<λ {a, c ? _, ...} → _>
│         └─body
│           └─<_ + _>
│             ├─lhs
│             │ └─`a`
│             │
│             └─rhs
│               └─`c`
│
└─body
  └─<_ or _>
    ├─lhs
    │ └─<_ . _>
    │   ├─lhs
    │   │ └─{_}
    │   │   ├─isRec
    │   │   │  └─false
    │   │   └─assignments
    │   │     └─0
    │   │       └─<_ = _>
    │   │         ├─lhs
    │   │         │ └─`r`
    │   │         │
    │   │         └─rhs
    │   │           └─<_ $ _>
    │   │             ├─func
    │   │             │ └─`f`
    │   │             │
    │   │             └─args
    │   │               └─0
    │   │                 └─`xs`
    │   │
    │   └─rhs
    │     └─<_._._>
    │       └─path
    │         └─0
    │           └─`r`
    │
    └─rhs
      └─`null`
#+END_SRC

** ~functions.nix~
- Lots of missing standard functional stuff
- A convenience library for building and working with ~Variadic~ functions

** Misc

- ~tests.nix~: Simple unit testing framework I wrote for these configs.
- ~log.nix~: Logging framework based around ~Variadic~ with support for the type system.
- ~nixlike.el~: Emacs library for agnostically running Nix expressions on the fly in either Nix REPL or Tvix REPL.
- Tests can be run via ~./test.sh~
