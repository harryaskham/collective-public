# Import shortcut
(load-file "nixlike.el")

# Quick toggles

(setq debug-on-error t)
(setq debug-on-error nil)

(setq nixlike-nix-variant 'nix)
(setq nixlike-nix-variant 'tvix)

(setq nixlike-kill-repl-before-eval nil)
(setq nixlike-kill-repl-before-eval t)

(setq nixlike-mode 'shell)
(setq nixlike-mode 'repl)

(setq nixlike-nix-eval-strategy 'eval)
(setq nixlike-nix-eval-strategy 'instantiate)

(nixlike-eval-command 'nix "123" 0 t nil)

<nix>
collective-lib._tests.run {}
</nix>

<nix>
typelib._tests.run {}
</nix>

<nix>
parser._tests.run {}
</nix>

<nix>
parser.parse ''{a = id} . a 1''
</nix>

<nix>
({a = add 10;} . a or (add 1)) 2
</nix>

<nix>
parser.parse ''x.f 1''
</nix>
<nix>
eval._tests.debug {}
</nix>

<nix>
{ inherit ({}) a; }
</nix>
<nix>
let f = { a ? 1, b, ... }: x: let data = rec { aa = a; inherit b x; sum = aa + b + x; }; in data.sum; in f {b = 4;} 5
</nix>
<nix>
with parser;
evalAST (parseAST "let a = {b = 1;}; in { inherit a; }")
#parseAST "let f = xs: x: let data = rec { aa = a; sum = aa + b + x; }; in data.sum; in f {b = 4;} 5"
#parseAST "let f = xs: x: let data = rec { aa = a; inherit b x; sum = aa + b + x; }; in data.sum; in f {b = 4;} 5"
#parse "let f = { a ? 1, b, ... }: x: let data = rec { aa = a; inherit ({}) x; sum = aa + b + x; }; in data.sum; in f {b = 4;} 5"
#parse "let f = { a ? 1, b, ... }: x: let data = rec { aa = a; sum = aa + b + x; }; in data.sum; in f {b = 4;} 5"
</nix>

<nix>
with parser; evalAST (parseAST "let f = {x ? 1, a ? 2, ...}: y: [x y]; in f {x = 3; abc = 1;}") 2
</nix>

<nix>
({a ? let x = 1; in x}: a) {}
</nix>

<nix>
let xs = {a = 1;};
    x = "a";
in { inherit (xs) "a"; }
</nix>

<nix>
with parser;
evalASTEither (parseAST "(1 == 1)")
</nix>
<nix>
log._tests.run {}
</nix>
<nix>
eval._tests.run {}
</nix>
<nix>
eval._tests.debug {}
</nix>
<nix>
parser._tests.run {}
</nix>
<nix>
-{a=1;}.a or {}.a or 1
</nix>

<nix>
#parser.parse ''f 1 2 3''
parser.parse ''a.b or d e''
#parser.parse ''a . b or (c d)''
#parser.parse ''a.b or id 1''
</nix>

<nix>
parser.parse ''{a = 1;}.a or const 1 2''
#with parser; (parseExpr ''{a = 1 + 1;}'')
</nix>
<nix>
#with parser; parse ''let f = x: x + 1; in f (if true then 42 else 0)''
with parser; parseExpr ''1 < 2 && 2 <= 3''
#with parser; parseExpr ''1 == 2 == 3''
</nix>

<nix>
parser._tests.run {}
</nix>

<nix>
(parser.N.string "ok")
</nix>
<nix>
let f = dispatch { int = add 1; float = x: x - 1; };
in {}.a or f 1 1.0

</nix>

<nix>
eval.monad._tests.run {}
</nix>

<nix>
with eval.monad;
let Int = {
  __toString = self: "Int";
  check = x: isInt (x.x or null);
  __functor = self: x: {
    inherit x;
    __type = Int;
    __toString = self: "Int ${_p_ self.x}";
  };
}; in

(Eval Int).pure (Int 1)
</nix>
